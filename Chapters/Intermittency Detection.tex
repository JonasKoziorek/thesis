\chapter{Intermittency Detection}
Section \ref{sec:ambiguous_bif_diag} of the previous chapter introduced the problem of ambiguity of the bifurcation diagram.
This chapter introduces an algorithm that aims to detect the ambiguity.
The algorithm consists of 3 core parts

% \begin{description}
% 	\item [1. Global Search] -- searching for areas where breakpoints occur
% 	\item [2. Local Search] -- searching for precise locations of breakpoints
% 	\item [3. Coloring] -- coloring the bifurcation diagram in proximity of breakpoints
% \end{description}

\begin{enumerate}
	\item \textbf{Global Search} -- searching for areas where breakpoints occur.
	\item \textbf{Local Search} -- searching for precise locations of breakpoints.
	\item \textbf{Coloring} -- coloring the bifurcation diagram in proximity of breakpoints.
\end{enumerate}

Each of these parts are described in the following sections.
The last section of this chapter combines all the parts together.

\section{Global Search}
The initial phase of the algorithm aims to find approximate parameter intervals during which type-I intermittency occurs.
More specifically, parameter intervals containing a breakpoint are identified.
\par
A breakpoint is a parameter value at which the system transitions from chaotic/intermittent behavior to periodic one.
The breakpoints of interest have chaotic behaviour on the left side and periodic behavior on the right side.
Each breakpoint can be identified by a unique number $n$ such that on the right side the behavior is $n$-periodic.
If parameter space could be searched through and the period of the system for each parameter value could be determined, the breakpoints could be easily found.
To do that an algorithm to determine the period of the system for any given parameter value is needed.
\par
If system has stable $n$-periodic orbit or the system starts evolving at unstable $n$-periodic point then the system is $n$-periodic or eventually $n$-periodic.
It is known that the Logistic map $\mathbb{L}_r$ can only have at most one unique stable $n$-periodic orbit for parameter $r$.
That means that if a stable $n$-periodic orbit is found for parameter $r$ then it is known that $\mathbb{L}_r$ is $n$-periodic.
At least in the case where initial condition is not an unstable periodic point.
To find out whether $\mathbb{L}_r$ has a stable $n$-periodic orbit it is needed to find fixed points of $\mathbb{L}_r, \mathbb{L}_{r}^{2}, \mathbb{L}_{r}^{3}, \dots$ and determine their stability.
Hence a smallest $n$ for which $\mathbb{L}_{r}^{n}(x^{*})=x^{*}$ and $x^{*}$ is stable is the period of $\mathbb{L}_r$.
\par
There exist algorithms for finding all fixed points of an arbitrary dynamical system.
These algorithms are quite efficient and can be used to for high-dimensional systems.
However, the aim is to search through the whole parameter space in search of breakpoints.
This search requires to find fixed points for hundreds or thousands of parameters in the parameter space.
Even though existing algorithms search for fixed points efficiently, they are not efficient enough.
They will come in handy later in the algorith but for now it is needed to find a way to approximate period of a system quickly.
\par
When periodic behavior is present in a bifurcation diagram, it means that the system is periodic or eventually periodic for a specific initial condition $x_0$.
In other words there exists $m > 0$ such that $f^{i}(x)=x$ is periodic for $i \geq m$.
A naive approach to determine whether a system is periodic is to simply iterate the system for some large enough $m$ and check whether $f^{m}(x)=f^{m+i}(x)$.
That implies that point $x$ is eventually periodic (or periodic) of period $i$.
\par
Simple check presented in the last paragraph fails to be precise in areas with intermittency.
The first $m$ iterations could end up in the laminar phase which might be deemed as periodic.
It also fails when the system is eventually periodic for some $n > m$, eg. higher than the parameter $m$.
Regardless of its flaws this simple check seems to be good enough for the naive search through the parameter space.
It is much quicker than finding all fixed points for each parameter and it is precise enough.
Pseudocode for the naive global search is presented in Algorithm~\ref{alg:naive_global_search}.

\begin{algorithm}[!h]
    \caption{Naive global search}
    \label{alg:naive_global_search}
    \begin{algorithmic}[1]
        \Statex $f \gets$ map
        \Statex $p_{A} \gets$ left boundary of the parameter space
        \Statex $p_{B} \gets$ right boundary of the parameter space
        \Statex $n \gets$ number of samples in the parameter space
        \Statex $m \gets$ number of iterations
        \Statex $o \gets$ maximum period to check
        \Statex $x_0 \gets$ initial condition
        \State $p \gets p_{A}$
        \State $p_{step} \gets \frac{p_{B} - p_{A}}{n}$
        \While{$p \leq p_{B}$}
            \State $x_1 \gets f_{p}^{m}(x_0)$
            \For{$i \gets 1$ to $o$}
                \State $x_2 \gets f_{p}^{i}(x_1)$
                \If{$x_2 = x_1$}
                    \State $f_p$ is $i$-periodic
                \EndIf
            \EndFor
            \State $p \gets p + p_{step}$
        \EndWhile
    \end{algorithmic}
\end{algorithm}

This algorithm is able to approximate the period of a system for each parameter in the parameter space.
If the algorithm does not find any periodicity for some parameter $p$ then it is assumed that the system is chaotic for this parameter.
The goal is to look for breakpoints, eg. regions where there is a shift from chaotic (non-periodic) behavior to periodic one.
To do that it is needed to use the results from the previous algorithm and identify places where two neighboring parameters change from no period to some period $n$.
As noted previously, the Naive global search is not very precise. For that reason verification of the parameters near the identified breakpoint with an algorithm for detection of periodic orbits is conducted.
\par
There are several efficient algorithms for unstable periodic orbits (UPOs) detection.
These algorithms are able to identify all points $x^{*}$ for which $f(x^{*})^{n}=x^{*}$ for any $n$.
The modern algorithms include Schmelcher-Diakonos algorithm~\cite{Schmelcher1997}, Davidchack-Lai algorithm~\cite{Davidchack1999,Davidchack2001,Klebanoff2001} and Bu-Wang-Jiang algorithm~\cite{Bu2004}.
An example of the Davidchack-Lai algorithm is shown in the Figure~\ref{fig:upo_search_example}.

\begin{figure}[!h]
    \centering
    \includegraphics[width=1.0\textwidth]{DDS/Figures/upo_search_example.png}
    \caption{
        \textcolor{red}{
        All fixed points of sixth iterate of Logistic map $\mathbb{L}_{r}^{6}$ for $r = 3.7$.
        These fixed points were detected using the Davidchack-Lai algorithm.
        }
    }
    \label{fig:upo_search_example}
\end{figure}

\par
It is worth mentioning that finding fixed points can be achiaved using standard methods too.
For example Newton-Raphson algorithm can be used to find roots of $g(x) = f(x)^{n} - x$.
However for high $n$ it becomes difficult to find these roots since there is too many of them and a chance of converging to a stable fixed point decreases.
Comparison of basins of convergence of the Newton-Raphson method, Schmelchel-Diakonos algorithm and Davidchack-Lai algorithm is given in~\cite{Davidchack1999}.
Another example is to use methods from theory of mathematical optimization.
Minimizing the following function $J(x)= \norm{f^{p}(x)-x}^{2}$ will yield a $p$-periodic point of $f$~\cite{Fuh2009}.
\par
We have decided to include the Bu-Wang-Jiang algorithm (BWJ) in our implementation.
It is easy to implement and works well enough.
The pseudocode for BWJ algorithm is presented in Algorithm~\ref{alg:bwj}.

\begin{algorithm}[!h]
    \caption{Bu-Wang-Jiang (BWJ)}
    \label{alg:bwj}
    \begin{algorithmic}[1]
        \Statex $f \gets$ map
        \Statex $p \gets$ period
        \Statex $seeds \gets$ seeds
        \Statex $maxiter \gets$ maximum number of iterations
        \Statex $tol \gets$ tolerance for determining a fixed point
        \For{each s in seeds}
            \State $\textbf{x}_{0} \gets s$
            \While{current iteration $< maxiter$}
                \State $J(\textbf{x}_{0}) = \partial f^{p}(\textbf{x}_{0}) / \partial \textbf{x}$ is jacobian at $\textbf{x}_{0}$
                \State $Q \gets (cI-J(\textbf{x}_{0}))(J(\textbf{x}_{0})-I)^{-1}$ where $I$ is identity matrix, $c \in (-1, 1)$ is a constant 
                \State $\textbf{x}_1 \gets f^{p}(\textbf{x}_{0}) + Q(f(\textbf{x}_{0})^{p}-\textbf{x}_{0})$
                \If{$\norm{f^{p}(\textbf{x}_1)-\textbf{x}_1} < tol$}
                    \State $\textbf{x}_{1}$ is a fixed point of $f^{p}$
                \EndIf
                \State $\textbf{x}_{0} \gets \textbf{x}_{1}$
            \EndWhile
        \EndFor
    \end{algorithmic}
\end{algorithm}

The $seeds$ parameter is a set of initial conditions from which the algorithm starts searching for fixed points.
They can be chosen as a uniformly sampled interval (if $x \in \mathbb{R}$) or grid (if $x \in \mathbb{R}^{n}$) in the state space.
Our version of the algorithm includes several optimizations suitable for our use case.
BWJ is able to find all fixed points of a system but only the stable fixed points are of interest are needed.
Logistic map is known to have at most one stable periodic orbit for each parameter $r$.
That means that after finding $n$ stable fixed points for the system $\mathbb{L}_{r}^{n}$ the algorithm can be terminated.
After finding a fixed point $x^{*}$ of $\mathbb{L}_{r}^{n}$, iteration of $x^{*}$ $n$ times is performed and check whether resulting points are also fixed points is conducted.
Before the algorithm starts similar idea as in the Naive global search is used.
The system $f^{n}(s)$ is iterated $m$ times for arbitrary ititial seed $s$ and check whether the resulting point is $n$-periodic is performed.
These optimizations make the algorithm more efficient.
The advantage of using BWJ algorithm to determine periodicity of a system $f_{p}$ is that it is reliable even if $f_{p}$ exhibits intermittency for parameter $p$.
\par
This section has introduced an algorithm to perform global search for breakpoints in the parameter space.
Firstly discretization of the parameter space is performed and the Naive global search is used to approximate periodicity of each parameter.
Afterwards neighboring pairs with nonperiodicity on the left side and periodicity on the right side are identified.
It is verified that Naive global search determined periodicity for these pairs correctly by using BWJ algorithm which is not prone to the effects of intermittency.
Finally ranges of parameters where a breakpoint occurance is expected are identified.
Example of the results of the algorithm are shown in the Figure~\ref{fig:bif_diag_search_example}.

\begin{figure}[!h]
    \centering
    \includegraphics[width=1.0\textwidth]{DDS/Figures/bif_diag_search_example.png}
    \caption{
        \textcolor{red}{
        An example of a Global search of the Logistic map $\mathbb{L}_{r}$.
        }
    }
    \label{fig:bif_diag_search_example}
\end{figure}

\section{Local Search}
The previous section introduced a so called global search, an approach to find approximate intervals in the parameter space where a breakpoint occurs.
This section introduces an algorithm to find the precise location of each breakpoint.
These locations will be later used to color the bifurcation diagram in proximity of the breakpoint.
\par
This section discusses two algorithms for the local search - Naive Local Search and Nested-Layer Particle Swarm Optimization.
The global search has already identified two boundaries $(p_A, p_B)$, period of the system with parameter $p_B$ and the fact there there is a breakpoint between $(p_A, p_B)$.
Subsequently it is needed to approximate the parameter at which the breakpoint occurs.
Both NLS and NLPSO solve this problem but they use different approaches.

\subsection{Naive Local Search}
The fundamental idea behind the Naive Local Search (NLS) is similar to the one used in the global search.
Parameter space will be searched through and the period of the system for each parameter value will be determined.
However, instead of performing the search for the whole parameter space, the search will be performed only in the intervals found in the global search.
These intervals are special because several facts about them are known.
Their left boundary is nonperiodic and their right boundary is periodic of period some $n$.
The $n$ is known from the global search.
The goal is to push the left boundary close to the left side of the breakpoint and the right boundary close to the right side of the breakpoint.
On example result of a NLS is given in Figure~\ref{fig:break_point_search_example}.

\begin{figure}[!h]
    \centering
    \includegraphics[width=1.0\textwidth]{DDS/Figures/break_point_search_example.png}
    \caption{Example result of the NLS}
    \label{fig:break_point_search_example}
\end{figure}



\par
Firstly the left boundary is searched.
It is desirable to get it as close to the breakpoint as possible.
To do this combination of BWJ algorithm and a binary search is used.
For each parameter $p$ in the interval $(p_{A}, p_{B})$ identified during the global search a check whether $f_{p}$ is $n$-periodic or not is performed.
That determines whether the breakpoint is on the left or right side of the parameter.
In the beginning the interval is halved in a way that $[p_{A}, \frac{p_{A}+p_{B}}{2}, p_{B}]$ is obtained.
If $\frac{p_{A}+p_{B}}{2}$ is $n$-periodic then it is known that the breakpoint is in the interval $[\frac{p_{A}+p_{B}}{2}, p_{B}]$.
If $\frac{p_{A}+p_{B}}{2}$ is nonperiodic then it is known that the breakpoint is in the interval $[p_{A}, \frac{p_{A}+p_{B}}{2}]$.
Using the new interval the same process is repeated recursively.
The halving process is repeated for some desired number of iterations $maxiter$.
Pseudocode for the NLS of the left boundary is given in Algorithm~\ref{alg:local_search}.

\begin{algorithm}[!h]
    \caption{NLS - left boundary}
    \label{alg:local_search}
    \begin{algorithmic}[1]
        \Statex $f \gets$ map
        \Statex $p_{A} \gets$ left boundary of the parameter space
        \Statex $p_{B} \gets$ right boundary of the parameter space
        \Statex $n \gets$ period of $f{p_{B}}$
        \Statex $maxiter \gets$ number of iterations
        \State $p_{C} \gets \frac{p_{A}+p_{B}}{2}$
        \State $i \gets$ current iteration
        \If{$i = maxiter$}
            \State left boundary of the breakpoint is $p_{A}$
        \EndIf
        \If{$f_{p_{C}}$ is $n$-periodic}
            \State repeat the algorithm with the same arguments except $p_{B} \gets p_{C}$ and $i \gets i+1$
        \Else
            \State repeat the algorithm with the same arguments except $p_{A} \gets p_{C}$ and $i \gets i+1$
        \EndIf
    \end{algorithmic}
\end{algorithm}

\par
The Algorithm~\ref{alg:local_search} searches only for left boundary. Search for right boundary can be done analogically.
The complete NLS is both the search of the left boundary and the search of the right boundary.
These two boundaries approximate precise location of a breakpoint.
By calculating the average $p_{avg}$ of the left and right boundary, a good approximation of the parameter at which the breakpoint occurs is obtained.
\par
This section introduces an algorithm which approximates the parameter at which the breakpoint occurs.
This parameter is also the bifurcation point at which a saddle-node bifurcation occurs.
This saddle-node bifurcation is the reason of the type-I intermittency on the right side of the break point.
The next section will describe how to visually warn about the locations of type-I intermittency.

\subsection{Nested-Layer Particle Swarm Optimization}
This section describes an alternative to the NLS algorithm.
It achieves the same goal as the NLS but uses different approach.
This is done by reformulating the original problem as an optimization problem.
\par
The NLS introduced in the last subsection approximates the parameter at which the breakpoint occurs.
It is based on the idea of a binary search.
However the search for the breakpoint can be rephrased as search for a parameter where saddle-node bifurcation occurs.
Matsushita, Kurokawa and Kousaka~\cite{Matsushita2019} introduced an approach to search for saddle-node bifurcation of a DDS.
Their method uses the Nested-Layer Particle Swarm Optimization (NLPSO) method.
They have previously used the same approach to detect period-doubling bifurcations of a DDS~\cite{Matsushita20170721}.
\par
Understanding how NLPSO detection of saddle-node bifurcation works requires understanding of the Particle Swarm Optimization (PSO).
PSO is popular population-based evolutionary algorithm.
It tracks several particles which represent potential solution.
Each particle has its own position and velocity. It also tracks its previous best position and score.
Each article moves through the search space based on its velocity and position.
Its movement is also influenced by its previous best position and best positions of other particles.~\cite{Matsushita2019}
\par
Each particle has a position $pos \in \mathbb{R}^{n}$, velocity $vel \in \mathbb{R}^{n}$, best position $bpos \in \mathbb{R}^{n}$ and best score $bscore \in \mathbb{R}$.
Algorithm also track global best position $g_{pos}$ and global best score $g_{score}$.
Pseudocode for the PSO algorithm is given in Algorithm~\ref{alg:pso}.
The algorith~\ref{alg:pso} includes several parameters.
These paramters are $w$, $c_{1}$ and $c_{2}$.
They shall be set as $w=0.729$ and $c_{1}=c_{2}=1.494$~\cite{Matsushita2019}.

\begin{algorithm}[!h]
    \caption{Particle Swarm Optimization (PSO)}
    \label{alg:pso}
    \begin{algorithmic}[1]
        \Statex $f \gets$ function to minimize. $f: \mathbb{R}^{m} \rightarrow \mathbb{R}$  
        \Statex $(a, b) \gets$ search-space range
        \Statex $n \gets$ number of particles
        \Statex $maxiter \gets$ maximum number of iterations
        \Statex $tol \gets$ tolerance for determining solution
        \Statex $w, c_{1}, c_{2} \gets$ parameters described in the text
        \State Create $n$ particles.
        \For{each particle}
            \State $pos$ $m$-dimensional vector of uniform random numbers between $a$ and $b$.
            \State $vel$ $m$-dimensional zero vector.
            \State $bpos \gets$ $m$-dimensional vector of uniform random numbers between $a$ and $b$.
            \State $bscore \gets \infty$
        \EndFor
        \State $g_{pos}$ $m$-dimensional vector of uniform random numbers between $a$ and $b$.
        \State $g_{score} \gets \infty$

        \For{iteration less than $maxiter$}
            \For{each particle}
                \State $score \gets f(pos)$ 
                \If{$score < bscore$}
                    \State $bscore \gets score$
                    \State $bpos \gets pos$
                \EndIf
                \If{$score < g_{score}$}
                    \State $g_{score} \gets score$
                    \State $g_{pos} \gets pos$
                \EndIf
            \EndFor
            \If{$g_{score} < tol$}
                \State break the loop
            \EndIf
            \For{each particle}
                \State $r_{1}, r_{2} \gets$ random numbers between $0$ and $1$.
                \State $vel \gets w(vel) + c_{1}r_{1}(bpos-pos) + c_{2}r_{2}(g_{pos}-pos)$
                \State $pos \gets pos + vel$
            \EndFor
        \EndFor
    \end{algorithmic}
\end{algorithm}

\par
The next step is to combine two PSOs.
One of them will be looking for a parameter $p_b$ at which saddle-node bifurcation occurs.
The other one will be looking for periodic point $x_b$ corresponding to $p_b$.
Each PSO requites a function that is to be minimized.
Its worth noticing that the algorithm works for dynamical systems of arbitrary dimensions.
For that reason the minimization functions are presented in a general form.
\par
Let $(\mathbb{R}^{m}, f)$ be a DDS.
Search for a periodic point $x_0$ for an arbitrary parameter $p$ is performed.
After selecting parameter $p$, a search for a periodic point $x_0$ is performed by minimizing the function $F$ from Eq.~\ref{eq:minimize_x}.
If $x_0$ is a fixed point of $f^{n}_{p}$ then $x_0$ is an $n$-periodic point of $f$.
It is a fixed point in case $f^{n}_{p}(x_0)-x_0 = 0$.
Hence minimizing the $F$ brings us closer to the $n$-periodic point.
PSO can be used to search for optimal parameter $x_0$ by minimizing $F$.

\begin{equation}
\label{eq:minimize_x}
    F(x_0) = \norm{f^{n}_{p}(x_0)-x_0}
\end{equation}

\par
Let $(\mathbb{R}^{m}, f)$ be a DDS.
A search for parameter $p_b$ at which saddle-node bifurcation occurs is performed.
Saddle-node bifurcation occurs at parameter $p$ when the characteristic equation~\ref{eq:characteristic_eq} is equal to $0$, $x_0$ is $n$-periodic point and parameter $\mu = 1$.
% Aditionally period-doubling bifurcation occurs when the when the characteristic equation~\ref{eq:characteristic_eq} is equal to $0$ and parameter $\mu = -1$.

\begin{equation}
\label{eq:characteristic_eq}
        \text{det}(Df^{n}_{p}(x_0)-\mu I)
\end{equation}
Hence minimize function $G_{mock}(p_0) = |\text{det}(Df^{n}_{p_0}(x_0)-\mu I)|$ for different parameters $p$ would search for saddle-node bifurcation $p_b$.
However in order to evaluate $G_{mock}$ it is needed to know $x_0$ which is currently unknown.
Thus a PSO can be used for minimizing~\ref{eq:minimize_x} to find $x_0$ and use $p_0$ as a system parameter that was described in the previous paragraph.
It is important to be sure that found point $x_0$ is $n$-periodic point and thus $G_{mock}$ is only evaluated if PSO converged correctly to $x_0$.
Updated function $G_{mock}$ is presented in Eq.~\ref{eq:minimize_p} and is now called $G$.
Thus minimizing the function $G$ from Eq.~\ref{eq:minimize_p} by PSO finds optimal parameter $p_b$.

\begin{equation}
\label{eq:minimize_p}
    G(p) =
    \begin{cases}
        |\text{det}(Df^{n}_{p}(x_0)-\mu I)| & \text{if } F(x_0) < C_{pp}, \\
        \infty & \rm{otherwise}
    \end{cases}
\end{equation}

\par
The previous paragraphs described how to use the two types of PSOs.
The main PSO looks for parameter $p_b$ at which saddle-node bifurcation occurs.
It does so by minimizing function $G$ from~\ref{eq:minimize_p}.
During every evaluation of $G$ at parameter $p_0$ it is needed to find $x_0$ which is $n$-periodic point of $f^{n}_{p_0}$.
That can be achieved by using the second nested PSO which minimizes function $F$ from~\ref{eq:minimize_x} by using $p_0$ as parameter in $F$.
This nesting of PSOs is the reason why this algorithm is called Nested-Layer Particle Swarm Optimization.
Period $n$ is the same in both functions $F$ and $G$.
It corresponds to the period of the system at the saddle-node bifurcation.
Fortunately the parameter $n$ is known from the global search.
Parameter range $(p_A, p_B)$ is also known from the global search and is used in the top-level PSO as search-space range.
The search-space range used for the nested PSO is also known.
It is because the system is invariant under some set.
For example for the Logistic equation, the search-space range can be set to $[0, 1]$.
\par
This subsection described the NLPSO algorithm as an alternative to NLS algorithm.
Both of these algorithms can be used interchangably when dealing with 1D systems.
However NLPSO is more general and can be used for higher dimensional systems as well.
In general NLPSO is much better algorithm than NLS.
Nevertheless it is also harder to implement and understand.

% \section{UPO detection}
% Our goal is to ultimately find regions in the bifurcation diagram where intermittency type-I occurs.
% As noted in chapter~\ref{chap:intermittency_review} we suppose that intermittency type-I is present at "breakpoints" in the bifurcation diagram.
% Such breakpoint is given for example in Figure~\ref{fig:complex_logistic}.
% \par
% The breakpoints are characterized by shift from chaotic to periodic behavior.
% Periodic behavior on one side of the breakpoint in the neighborhood of it always has some fixed period $n$.
% Hence the system has $n$ stable fixed points on one side of the breakpoint.
% On the other side the behavior is dynamic and there are no stable fixed points.
% If we could quickly determine whether system for chosen parameter $p$ is periodic or not we could use this knowledge to find the breakpoints.
% The reason for that is that on one side of the breakpoint the check of periodicity would always yield infinity and on the other side it would yield period $n$.
% We could use this knowledge to get arbitralily close to the breakpoint.
% \par
% To check whether a system $f_P$ is $n$ periodic we just need to determine the number of stable fixed points of system $f^{n}_P$.
% If number of the stable fixed points is $n$ then system $f_P$ is $n$ periodic.
% If we know that $x_0$ is a stable fixed point of $f^{n}_P$ then we know that it is $n$ periodic point.
% The remaining $n-1$ points of the stable periodic orbit can be found by iterating $f_P(x_0)$ $(n-1)$-times.
% However how do we reliably and algorithmically get the first periodic orbit?
% \par
% Finding a fixed point of $f^{n}_{P}$ is a question of finding a root of $g(x) = f^{n}_{P}(x) - x$.
% Standard root finding algorithm such as Newton-Raphson algorithm can be used to finds roots of $g(x)$.
% However for high $n$ it becomes difficult to find these roots since there is too many of them and a chance of converging to a stable fixed point decreases.
% Since our algorithm requires certainty that we found complete stable periodic orbit we decided to take another approach.
% \par
% Other option is to find all periodic orbits and determine their stability.
% There exist quick algorithm to determine all periodic orbits.
% By using it we will always have certainty that we found all stable periodic orbits.

% \subsection{Schmelcher-Diakonos algorithm}
% Schmelcher and Diakonos came up with a general algorithm for detecting complete set of unstable periodic orbits.
% The algorithm transforms the original system so that its unstable fixed points become stable.
% Additionally their basins of attraction are long and convergence to each unstable orbit is probable.
% However number of system transformations grow very quickly for high dimentional systems and computation becomes too long.
% At the same time parameter $\lambda$ has to be specified correctly to ensure convergence but there is no general way of how to choose this parameter.~\cite{Schmelcher1997}

% \subsection{Davidchack-Lai algorithm}
% Davidchack and Lai extended SD algorithm so that it works as a hybrid between Newton-Raphson algorithm and SD algorithm.
% They propose that to find UPOs of period $n$ one can use UPOs of period $n-1$ and $n+1$.
% This technique is supposed to reduce number of iterations significantly compared to SD algorithm.~\cite{Davidchack1999}

% \subsection{Our implementation}
% DL algorithm is supposed to be superior to SD algorithm.
% Even though there the DL algoritm is described in~\cite{Davidchack1999,Davidchack2001,Klebanoff2001} we were not able to implement it in a way that would fulfill its advertised performance.
% Since the algorithm is over 20 years old and there are no implementations of it online we had to resort to our own version.
% \par
% Our version simply the DL iteration scheme but does not use previously UPOs as seeds.
% We choose seeds uniformly from an interval as it was suggested for SD algorithm~\cite{Schmelcher1997}.
% We use efficient binary search tree structure which makes the algorithm efficient enough for our use case.
% Example of the results of the algorithm are shown in the Figure~\ref{fig:upo_search_example}.

% \begin{figure}[!h]
%     \centering
%     \includegraphics[width=1.0\textwidth]{DDS/Figures/upo_search_example.png}
%     \caption{All unstable periodic orbits}
%     \label{fig:upo_search_example}
% \end{figure}


% \section{Global Search}
% Thanks to algorithm from the previous section we are able to find potential intervals in the bifurcation diagram containing type-I intermittency.
% We start by selecting range of parameters $(p_{A}, p_{B})$ in which we would like to search for intermittency.
% We discretize $(p_{A}, p_{B})$ to $n$ uniformly spaced samples.
% We go through each sample $p$ and check if it is $f_p$ is $m$-periodic.
% We only check periods $m$ until a certain limit $m_{limit}$.
% If we cannot detect any period we simply denote this boundary point as $m_{limit}+1$ which can be understood as infinity.
% Since we know period of each sample we simply compare periods of neighboring samples.
% If we spot a difference between period of sample $a$ and sample $b$, then a bifurcation must have occured in the interval $(a, b)$.
% Additionally if $a=m_{limit}+1$ and $b \leq m_{limit}+1$ then we have found an interval which potentionally contains a breakpoint.
% \par
% Figure~\ref{fig:bif_diag_search_example} illustrates global search through bifurcation diagram of Logistic map for periods up to 18.
% Two lines of the same color represent an interval in which bifurcation occurs.
% We are looking for breakpoints associated with saddle-node bifurcations.
% These breakpoints are hence also identified by this search.

% \begin{figure}[!h]
%     \centering
%     \includegraphics[width=1.0\textwidth]{DDS/Figures/bif_diag_search_example.png}
%     \caption{Global search example}
%     \label{fig:bif_diag_search_example}
% \end{figure}

% \section{Local Search}
% Once we identify suspicious intervals through global search we can search locally for precise location of a breakpoint.
% Again we utilize the ability to determine number of period of $f_p$ for some $p$.
% Since we know that to the left of the breakpoint there is no periodicity and to the right there is always the same periodicity, we can effectively search for the midpoint.
% We can use similar approach as in the traditional binary search.
% We start with an interval found by global search.
% We know that left boundary has no periodicity and right boundary has periodicity.
% We split the interval and check if the boundaries retain its properties.
% If property at the boundary changes we simply update the initial interval and start the algorithm recursively again.
% This way we are able to precisely locate the breakpoint parameter.
% \par
% An example of the found breakpoint is illustrated in Figure~\ref{fig:break_point_search_example}.

% \begin{figure}[!h]
%     \centering
%     \includegraphics[width=1.0\textwidth]{DDS/Figures/break_point_search_example.png}
%     \caption{Local search example}
%     \label{fig:break_point_search_example}
% \end{figure}


\section{Coloring}
The goal of this phase is to color the neighborhood of the breakpoint to warn about its ambiguity.
Parameters at which the breakpoint occurs were found in the previous steps.
Now statistical methods are used to determine the average laminar phase length $l_{avg}$ in proximity of the breakpoint.
These statistical methods are described in~\cite{Elaskar2022}.

\subsection{Description of the algorithm}

\begin{figure}[!h]
    \centering
    \includegraphics[width=0.8\textwidth]{DDS/Figures/logistic_map_coloring_example.png}
    \caption{Bifurcation diagram coloring example}
    \label{fig:coloring_example}
\end{figure}

\section{Complete algorithm}

\endinput